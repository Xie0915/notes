# Java并发编程

## 11、显示锁 Lock

**为什么显示锁**？

​	内置锁局限性：无法中断一个正在获取锁的线程；无法获取锁时无限等待下去；必须在获取该锁的代码中释放，因此无法实现非阻塞的加锁规则

**轮询锁与定时锁**

​	`trylock`方法获取锁，如果不能获取锁将释放所有的锁并尝试重新获得锁，会进行一段时间的休眠，包含固定部分和随机部分

​	如果在带有时间限制的操作中调用了一个阻塞方法，会根据剩余时间提供一个时限，操作不能在指定时间结束的话会提前终止程序。而内置锁则无法取消

**可中断的锁获取操作**

​	`lockInterruptibly`获得锁的同时保持对中断的相应

**非块结构的加锁**

​	降低锁的粒度，例如对一个链表中的节点加锁

### 3、公平性

- 公平的锁：按照请求的顺序来获得锁，维护一个队列
- 非公平锁：允许插队，如果发出请求的同时一个锁的状态变为可用，则跳过队列直接获得锁

大多数情况下，非公平锁的性能优于公平锁，有一个重要的原因：**恢复一个被挂起的线程与该线程真正运行之间存在严重的延迟**

### 4、选择sychronized或是Reentrantlock

在内置锁无法满足要求的时候使用Reentrantlock，包括：可定时、轮询、中断的锁获取操作，公平队列以及非块结构的锁，否则优先使用synchronized

Reentrantlock还能给出哪些调用帧获得了哪些锁，能够检测和识别石锁发生，但是不能和特定的栈帧联系起来

### 5、读写锁

`ReentrantReadWriteLock`

读取锁和写入锁只是读-写锁对象的不同视图





# 5 并发容器类

## 2、并发容器

### 2.1 ConcurrentHashMap

​    用一种粒度更细的加锁机制来实现更大程度的共享（分段锁），任意数量的读线程可以并发访问Map，一定数量的写线程可以并发修改Map，并发访问下实现更高的吞吐量，单线程中损失一小部分的性能

​	不会抛出`ConcurrentModificationException`因此不需要对容器进行加锁，ConcurrentHashMap返回的迭代器具有**弱一致性**，迭代器可以容忍并发修改，创建时会遍历所有的元素，在迭代器构造后将修改的操作返回给容器

​	ConcurrentHashMap中提供了一些原子操作（因为不能加锁）

```java
V putIfAbsent(K key, V value)
    ...
```

### 2.3 CopyOnWriteArrayList

​	用于替代List，在同步过程中不需要对容器进行加锁



**阻塞方法与中断方法**

​	三种状态：`BLOCKED` `WAITING` `TIMED_WAITING`

​	阻塞操作必须等待某个不受它控制的事件发生后才能继续执行，如等待IO 等待锁等，当外部事件发生后，重回`Runnable`状态

​	如果一个方法抛出`InterruptException`,表明该方法是一个阻塞方法，如果调用了一个将抛出`InterruptException`方法，该方法也成为了一个阻塞方法，需要处理这个异常

​	1、传递`InterruptException`:不做任何处理，抛出；或者简单处理，抛出

​	2、恢复中断：捕获异常，调用`Interrupt`方法

​	Thread提供了`Interrupt`方法，用于中断线程或者是查询线程是否中断



#### 同步工具类：

​	根据自身状态来协调线程的控制流，如阻塞队列，信号量，栅栏，闭锁等

​	特点：

​		1、封装了一些状态    2、提供了一些方法对状态进行操作   3、提供一些方法用于高效等待同步工具类

​	**闭锁：**

​		闭锁到达结束状态之前，所有线程都阻塞，下述应用

​	        确保计算在所有资源都加载完成后才进行

​			确保某个服务在其依赖的所有服务启动后启动

​			等待某个操作所有参与者都就绪

​		`CountDownLatch`包括一个计数器，初始化为一个正数，表示需要等待的事件数量，`countDown`方法递减计数器，`await`方法阻塞至计数器变为零













## 二 线程安全性

​	对状态访问操作进行管理，包括共享以及可变状态；同步操作包括sychronized（内置锁）显示锁 原子操作 不可变对象

​	封装性越好，越容易实现程序的线程安全性

**什么是线程安全性**

​	正确性：某个类的行为与其规范完全一致。良好的规范通常会定义不变性状态来约束对象的状态，以及后验条件来描述对象操作的结果

​	线程安全性：多个线程访问同一个类时，这个类始终能够表现出正确的行为，这个类就是线程安全的

​	**无状态的对象一定是线程安全的**

**原子性**

​	**竞态条件**

​		某个计算的正确性取决于多个线程交替执行的时序，就会发生竞态条件，最简单的竞态条件就是check-then-act，或者读取-修改-写入操作

​	**复合操作**

​		上述先检查后执行以及读取-修改-写入都是复合操作，这类操作可以调用`java.util.concurrent.atomic`中的原子变量，例如`AtomicLong`这能表示对状态的访问操作都是原子的

​		在无状态的对象中添加**一个**状态时，如果这个状态完全由线程安全的对象来管理，这个类也是线程安全的

**加锁机制**

​	用多个线程安全的变量来表示对象的状态并不是完全的线程安全的，因为这些对象的状态并不是完全独立的，例如如果有两个状态变量需要同时进行更新（用AtomicRefference来表示缓存）

​	**因此，要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量**

​	**内置锁**

​		内置锁相当于一种互斥锁，获取锁的唯一方法是进入同步代码块

​	**重入**

​		设置一个计数值以及一个所有者线程，请求一个未被持有的锁，JVM将记下锁的持有者，并将计数值+1，当同一个线程重复获得锁时，计数值递增，计数值为0时，锁释放。这也表明获取锁操作的粒度为“线程”，而不是调用

​	**活跃性与性能**

​		不应将同步代码块分得过细，因为获取和释放锁都需要一定的开销。

​		通常，简单性与性能之间会相互制约，但盲目地牺牲简单性可能会带来安全性上的问题



​		



## 六 任务执行

**线程中执行任务**

​	**无限制创建新线程**

​		不足：

​			1、线程生命周期开销非常高，创建需要时间，且取药JVM与操作系统一些辅助操作

​			2、资源消耗：消耗系统资源，尤其是内存，如果运行线程数大于处理器数量，会闲置

​			3、稳定性：可创建线程的数量随着平台的不同而不同

**Executor框架**

​	java类库中，任务执行的主要抽象不是Thread，而是Executor

```java
public interface Executor{
    void execute(Runnable command);
}

//同步进行
pulbic execute(Runnable r){
    new Thread(r).start();
}

//串行进行
public execute(Runnable r){
    new Thread(r).run();
}
```

​	基于生产者、消费者模式，提供任务的为生产者，执行任务的线程为消费者

​	可以设置执行策略，包括执行顺序，并发数，过载时操作，执行前后操作等

​	**线程池**

​		工作者线程（Worker Thread）：从工作队列（Work Queue）中获得一个任务，执行任务，然后返回线程池

​		优势：1、分摊线程创建和销毁的开销  2、减少创建线程的延迟

```java
//Executor中静态工厂方法创建线程池

newFixedThreadPool;
newCachedThreadPool;
...
```

​	**Executor 生命周期**

​		

​	

​	