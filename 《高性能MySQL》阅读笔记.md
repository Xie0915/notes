# 一、MySQL架构与历史

MySQL是分层架构，上层服务层与查询执行引擎，下层为存储引擎

## 1.2 并发控制

### 1.2.1 读写锁

- **读锁(read lock)\共享锁(shared lock)**：共享的，相互不阻塞

- **写锁(write lock)\排他锁(exclusive lock)**：排他的，阻塞其他的写锁和读锁

### 1.2.2 锁粒度

让锁定对象更有选择性，但是加锁也需要消耗资源，因此需要制定一定的锁策略，即在锁的**开销与安全性**之间寻求平衡，一般是在表上施加**行级锁(row-level lock)**，而MySQL中存储引擎可以实现自己的锁策略

- 表锁(table lock)：

  开销最小，锁定整张表，读锁之间不互相阻塞；

  特定的场景中表锁可能有良好性能，例如Read LOCAL表锁；另外，有可能写锁会具有比行锁更高的优先级

- 行级锁(row lock)：

  开销最大，但是最大程度上支持并发，InnoDB和XtraDB支持行级锁

## 1.3 事务

事务是一组原子性的SQL查询，或者说是一个独立的工作单元，要么全部执行成功，要么全部执行失败

下即一个事务

```sql
START TRANSACTION;
SELECT balance FROM checking WHERE customer_id = 123;
UPDATE checking SET balance = balance - 200.00 WHERE customer_id = 123;
UPDATE savings  SET balance = balance + 200.00 WHERE customer_id = 123;
COMMIT;
```

- **ACID**：
  - **原子性(atomicity)**：一个事务是一个不可分割的最小工作单元
  - **一致性(consistency)**：数据库从一个一致性转移到另一个一致性状态，上面例子中，当执行到第三步时系统崩溃，则修改不会保存到数据库
  - **隔离性(isolation)**：修改在提交之前对其他事物通常不可见
  - **持久性(durability)**：一旦事物提交，所做的修改将永远保存在数据库中

- ACID需要更多的资源（CPU，内存）等，根据业务是否需要事务处理选择合适的存储引擎，即使不支持事务也可以通过LOCK TABLES等语句提供一定程度保护

### 1.3.1 隔离级别

|          | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| -------- | ---- | ---------- | ---- | ------ |
| 读未提交 | YES  | YES        | YES  | NO     |
| 读已提交 | NO   | YES        | YES  | NO     |
| 可重复读 | NO   | NO         | YES  | NO     |
| 可串行化 | NO   | NO         | NO   | YES    |

### 1.3.2 死锁

死锁指两个或多个事务在同一资源上的相互占用，死锁检测和死锁超时；

InnoDB目前的方式是回滚持有最少行级排它锁的事务；

死锁产生有可能因为数据冲突，有可能因为存储引擎的实现方式

事务型系统，死锁发生时只能回滚其中一个事务

### 1.3.3 事务日志

修改表数据的时候变为修改**内存拷贝**，再将修改行为记录到**持久的硬盘事务日志**中，然后在后台慢慢刷回磁盘

事务日志是**顺序写的，因此速度快**，不用再磁盘多个地方移动表头；当仅写入日志时系统发生崩溃，也可在重启后进行恢复

### 1.3.4 MySQL中的事务

- 自动提交(AUTOCOMMIT):

  每一个查询都将当做一个事务执行提交操作，除非显示执行COMMIT或ROLLBACK

  MyISAM或内存表，不支持事务，可以说一直处于AUTOCOMMIT状态

  ```mysql
  //修改是否自动提交
  SET AUTOCOMMIT = 0;
  SET AUTOCOMMIT = 1;
  
  //修改事务隔离级别
  SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
  ```

- 混合使用存储引擎（如InnoDB和MyISAM）

  非事务性的表不能回滚，MySQL只有在需要回滚的时候才会发出警告。

- 隐式与显式锁定

  InnoDB采用两阶段锁定协议。事务执行阶段随时可以锁定（隐式）。但只有在COMMIT或者ROLLBACK时释放。InnoDB也支持特定的语句显式锁定

  ```mysql
  SELECT...LOCK IN SHARE MODE
  SELECT...FOR UPDATE
  ```

  MySQL同时支持LOCK TABLES和UNLOCK TABLES，但是这些在服务层实现（针对MyISAM）。但InnoDB的行级锁更有效率

## 1.4 多版本并发控制（MVCC）

MVCC是行级锁的变种，大多数实现了非阻塞的读，写操作则是锁定特定的行；其实现方式典型的有乐观并发控制与悲观并发控制；只在**可重复读与读已提交**两个隔离级别下工作

**实现方法：保存数据某个时间点的快照**

InooDB：在每行记录后保存两个隐藏的列，一个保存行的创建时间，一个保存行的过期时间（删除时间），这里时间指系统版本号，每开始一个新的事务，系统版本号加一。

对于可重复读的隔离，下列操作：

- SELECT:

  1. 只查找版本早于当前事务版本的数据行
  2. 只查找删除版本未定义或大于当前事务版本号的数据行

- INSERT：

  保存当前系统版本号作为行版本号

- DELETE：

  保存当前系统版本号为行删除版本

- UPDATE：

  保存当前系统版本为行版本号，并将系统版本作为原行的删除版本号

## 1.5 MySQL的存储引擎

- InnoDB概览
  - 数据存储在表空间（tablespace），表空间是黑盒子，由一系列数据文件组成；数据和索引可分别保存；InooDB可以使用裸设备作为存储介质
  - 用MVCC支持高并发，实现四个级别的隔离，默认可重复读（REPEATABLE READ）
  - 基于聚簇索引；存储格式平台独立
  - 内部优化，包括预读、自适应哈希索引，插入缓冲区
  - 支持热备份
- 优先选择InnoDB，尽量不要混合多种存储引擎





# 五、创建高性能索引

对于数据量较大的情况，索引对性能影响很大，是对查询性能优化最有效的手段；而在小的表上，全表搜索通常更高效；对于超大型的表，建立索引代价很大，可以采用分区技术

## 5.1 索引基础

在存储引擎实现，不同存储引擎工作方式不同

### 5.1.1 索引类型

- **B-Tree类型**

  意味着索引是按顺序存储的，所有叶节点到根节点的深度相同；节点页与叶子页，节点页的槽中存储指向下层子节点的指针，叶节点则存储指向数据的指针

  ![1560046836735](C:\Users\xieyu\AppData\Roaming\Typora\typora-user-images\1560046836735.png)

  **可以使用B-Tree索引的查询类型：**

  - 全值匹配：和索引中所有列的值进行匹配
  - 匹配最左前缀：匹配索引的第一列
  - 匹配列前缀：匹配某一列值的开头部分
  - 匹配范围值：查找值在某一个范围内的数据行（顺序存储）
  - 精确匹配某一列并范围匹配另一列：一列全匹配，一列范围匹配
  - 只访问索引的查询：“覆盖索引”优化

  **B-Tree的限制：**

  - 需要从索引最左列开始查找
  - 不能跳过索引中的某一列
  - 如果包含范围值，则右边所有的列无法使用索引优化

  这些限制与索引列的顺序有关

  

- **哈希索引**

  为每一行计算一个hash值，保存一个哈希表，表中存储指向每一个数据行的指针，索引结构紧凑。

  MySQL中，只有Memory存储引擎显示支持hash索引，InnoDB中有自适应的哈希索引，当有些索引值被频繁引用时，在B-Tree的基础上再创建一个哈希索引

  hash索引限制：

  - 不存储字段值，只存储行指针
  - 不是按照索引值顺序保存的，无法用于排序
  - 不支持部分索引列匹配查找，因为哈希索引使用索引列的全部内容计算哈希值
  - 只支持等值比较查找
  - 可能出现哈希冲突，冲突很多的话维护困难

  创建一个哈希索引：

  - 例如，对url创建哈希，创建一个url 的哈希列
  - 对于哈希列的维护，有两种方式：
    - 手动维护
    - 触发器维护：不要使用SHA1和MD5作为哈希函数，这是两个强加密函数

- 空间数据索引（R-Tree）：组合不同的维度，而不需前缀查询
- 全文索引

## 5.2 索引的优点

1. 大大减少服务器需要扫描的数据量
2. 帮助服务器避免排序和临时表（ORDER BY, GROUP BY）
3. 将随机I/O变为顺序I/O



三星索引：

1、将相关的记录放在一起

2、索引中数据顺序与查找中的顺序相同

3、索引列包含查询中的所有列



## 5.3 高性能索引策略

### 5.3.1 独立的列

索引列不能是表达式的一部分，也不能是函数的参数，否则MySQL不会使用索引，因此**==需要简化WHERE==**

```mysql
// 带有表达式的列
SELECT id FROM actor WHERE id + 1 = 5;

SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TODAYS(date_col) <= 10
```

### 5.3.2 前缀索引与索引选择性

当需要索引很长的字符列时，通过通过前缀索引来节省索引值，一般情况下一个列的前缀也具有较高的选择性



空间

**索引的选择性：不重复的索引值与数据表记录总数的比值**

选择合适前缀的方法：

- 找到最常见值列表，然后和最常见的前缀列表进行比较
- 计算完整列的选择性，并使前缀列的选择性接近完整列

创建前缀索引：

```mysql
ALTER TABLE city_demo ADD KEY (city(7))
```

前缀索引缺点：MySQL无法使用前缀索引做ORDER BY 和 GROUP BY， 也无法用其做覆盖扫描

一个很常见的场景是对UUID做前缀索引



### 5.3.3 多列索引

为每个列单独创建索引一般是低效的，在MySQL 5.0 后，MySQL会优化复杂查询，使用union或intersection处理。但是，通常情况下，会导致：

- 当有多个AND条件时，意味着需要一个单独的包含相关列的索引，而不是多个独立索引
- 当有OR条件时，需要耗费很多资源在CPU和内存资源的缓存、排序和合并，特别是索引选择性不高
- 优化器不会计算上述成本，只关心随机页面的读取，使得查询的成本被低估，有的时候这样的执行计划不如走全表扫描

如果在Explain中看到有索引合并，需要考虑一下是不是最优



### 5.3.4 选择合适的索引列顺序（适合B-Tree索引）

按照实际与经验法则（经验法则将**选择性更高的放在最前列**）

性能不仅仅依赖所有索引列的选择性，也和**查询条件的具体值（即值的分布有关）有关**

同时需要考虑排序、分组和范围条件等因素



### 5.3.5 聚簇索引

是一种数据存储方式，InnoDB在同一个结构中保存了B-TREE索引和数据行

当表有聚簇索引的时候，它的数据行实际上是放在叶子节点中，一个表只能有一个聚簇索引，InnoDB通过主键聚集数据

聚簇索引的优点：

1、相关数据保存在一起（聚集数据，顺序IO） 2、数据访问更快，不用回表查询

缺点：

1、I/O密集型应用较好，如果数据全部放在内存中，就无所谓了

2、插入速度依赖于插入顺序，如果不是按主键顺序插入，最好用OPTIMIZE TABLE组织一下

3、更新聚簇索引代价比较大，会移动被更新得行

4、插入新行，或者移动行时，可能发生页分裂为题，导致表占用更多磁盘空间

5、全表扫描较慢，尤其表比较稀疏的时候，或者页分裂导致数据不连续的时候

6、二级索引可能较大，且访问二级索引需要两次查找 



### 5.3.6 覆盖索引

如果一个索引包含了所有需要查询的字段的值，就称为覆盖索引

优点：

1、索引条目远小于数据行大小，提高I/O的速度，缓存的负载也更小，然后能将更多的东西存入缓存，对于I/O密集型应用效果很好

2、索引按列值顺序存储

3、一些存储引擎只会缓存索引值，例如MyISAM，数据依赖操作系统缓存，因此查询数据时会产生系统调用，从而产生性能问题

4、InnoDB不用二次查询



### 5.3.7 使用索引扫描来排序

只有当索引的列顺序和ORDER BY子句顺序完全一致的时候，并且所有列的排序方向都一样时，MySQL才能用索引来做排序，如果查询关联多张表，只有ORDER BY子句引用字段都是第一张表的时候才能使用索引做排序

有一种情况可以不遵守最左前缀的规则，就是orderby最左前缀用的是常量



### 5.3.8 冗余索引

有的时候需要冗余索引，比如一个A索引，不是扩展成（A,B）而是创建一个新的索引(A,B)，这样做的好处是当原来索引已经足够大的时候，再扩展这个索引可能会导致查询性能下降，从而影响其他单单使用（A）索引的查询



## 5.4 索引案例学习

支持多个过滤条件

选择性不高、但是经常使用的列也可以加入索引列，使用时用IN()来遵守最左前缀原则，范围查询通常放到最后，避免创建多个索引，可以用IN

避免多个范围条件

可以优化表结构或者是应用程序

优化排序

延迟查询



# 六、查询优化

## 6.2 优化数据访问

1、确认应用程序是否在检索大量超过需要的数据，访问太多的行

2、确认Mysql服务器层是否在分析大量超过需要的数据行

### 6.2.1 是否请求不需要的数据

- 查询不需要的记录

  MySql通常先返回全部结果集再进行计算（先SELECT查询大量的结果，然后获取前N行并关闭结果集），最简单有效的方法是加上LIMIT

- 多表关联时返回全部列

- 总是取出全部列

  SELECT *, 优化器无法完成索引覆盖扫描这类优化







